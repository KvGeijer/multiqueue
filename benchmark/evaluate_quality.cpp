#include <algorithm>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <numeric>
#include <set>
#include <unordered_map>
#include <vector>

#include "cxxopts.hpp"

struct insertion_log {
    uint64_t tick;
    uint64_t key;
};

bool operator<(insertion_log const& lhs, insertion_log const& rhs) {
    return lhs.tick < rhs.tick;
}

bool operator==(insertion_log const& lhs, insertion_log const& rhs) {
    return lhs.key == rhs.key && lhs.tick == rhs.tick;
}
bool operator!=(insertion_log const& lhs, insertion_log const& rhs) {
    return !(lhs == rhs);
}

static constexpr unsigned int bits_represent_thread_id = 8;
static constexpr uint64_t thread_id_mask = (static_cast<uint64_t>(1u) << (64u - bits_represent_thread_id)) - 1u;

struct log_value {
    uint64_t data;

    log_value(uint64_t from_uint) noexcept : data{from_uint} {
    }
    log_value(unsigned int thread_id, uint64_t elem_id) noexcept {
        data = (static_cast<uint64_t>(thread_id) << (64u - bits_represent_thread_id)) | (elem_id & thread_id_mask);
    }
    constexpr unsigned int thread_id() const noexcept {
        return static_cast<unsigned int>(data >> (64u - bits_represent_thread_id));
    }
    constexpr uint64_t elem_id() const noexcept {
        return data & thread_id_mask;
    }
    operator uint64_t() const noexcept {
        return data;
    }
};

struct deletion_log {
    uint64_t tick;
    log_value value;
};

int main(int argc, char* argv[]) {
    std::filesystem::path in;
    std::filesystem::path del;
    std::filesystem::path out_rank;
    std::filesystem::path out_delay;

    cxxopts::Options options(argv[0], "Parses the logs generated by the quality benchmarks");
    options.positional_help("INSERT DELETION");
    // clang-format off
    options.add_options()
      ("insert_file", "The log of the insertions", cxxopts::value<std::filesystem::path>(in), "PATH")
      ("delete_file", "The log of the deletions", cxxopts::value<std::filesystem::path>(del), "PATH")
      ("r,out-rank", "The output of the rank histogram", cxxopts::value<std::filesystem::path>(out_rank)->default_value("rank_histgram.txt"), "PATH")
      ("d,out-delay", "The output of the delay histogram", cxxopts::value<std::filesystem::path>(out_delay)->default_value("delay_histogram.txt"), "PATH")
      ("positional", "", cxxopts::value<std::vector<std::filesystem::path>>())
      ("h,help", "Print this help");
    // clang-format on

    options.parse_positional({"insert_file", "delete_file", "positional"});

    try {
        auto result = options.parse(argc, argv);
        if (result.count("help")) {
            std::cerr << options.help() << std::endl;
            std::exit(0);
        }
        if (result.count("insert_file") == 0 || result.count("delete_file") == 0) {
            std::cerr << "Provide insertion file and deletion file!\n\n";
            std::cerr << options.help() << std::endl;
            std::exit(1);
        }
    } catch (cxxopts::OptionParseException const& e) {
        std::cerr << e.what() << '\n';
        return 1;
    }

    std::vector<std::vector<insertion_log>> insertions;
    std::vector<deletion_log> deletions;
    auto in_f = std::ifstream{in};
    auto del_f = std::ifstream{del};
    if (!in_f.is_open()) {
        std::cerr << "failed to open " << in << '\n';
        return 1;
    }
    if (!del_f.is_open()) {
        std::cerr << "failed to open " << del << '\n';
        return 1;
    }
    {
        std::clog << "Reading insertion file...\n";
        unsigned int thread_id;
        uint64_t tick;
        uint64_t key;
        while (in_f >> thread_id >> tick >> key) {
            if (thread_id >= insertions.size()) {
                insertions.resize(thread_id + 1);
                insertions[thread_id].reserve(10000);
            }
            insertions[thread_id].push_back(insertion_log{tick, key});
        }
        in_f.close();
    }
    {
        std::clog << "Reading deletion file...\n";
        unsigned int thread_id;
        uint64_t tick;
        unsigned int other_thread_id;
        uint64_t id;
        deletions.reserve(1'000'000);
        while (del_f >> thread_id >> tick >> other_thread_id >> id) {
            deletions.push_back(deletion_log{tick, {other_thread_id, id}});
        }
        del_f.close();
    }
    /* std::cout << "Num deletions: " << deletions.size() << std::endl; */
    std::clog << "Sorting deletions...\n";
    std::sort(deletions.begin(), deletions.end(), [](auto const& lhs, auto const& rhs) { return lhs.tick < rhs.tick; });
    std::vector<size_t> rank_histogram;
    std::vector<size_t> delay_histogram;
    rank_histogram.reserve(10'000);
    std::clog << "Evaluating deletions...\n";
    std::multimap<uint64_t, size_t> replay_heap{};
    std::vector<size_t> insert_index(insertions.size());
    uint64_t failed_deletions = 0;
    size_t counter = 0;
    size_t progress = 0;
    for (auto const& [tick, value] : deletions) {
        if ((10 * counter) / deletions.size() >= progress) {
            std::clog << "Processed " << std::setprecision(3)
                      << 100. * static_cast<double>(counter) / static_cast<double>(deletions.size()) << "%\n";
            ++progress;
        }
        ++counter;
        /* std::cout << "Deletion tick is at " << tick << std::endl; */
        if (value.thread_id() == (1u << 8) - 1) {
            if (!replay_heap.empty()) {
                for (auto& [num, delay] : replay_heap) {
                    ++delay;
                }
                ++failed_deletions;
                ++rank_histogram[static_cast<size_t>(replay_heap.size())];
            }
            continue;
        }
        if (value.thread_id() >= insertions.size() || value.elem_id() >= insertions[value.thread_id()].size()) {
            std::cerr << "No insertion corresponding to deletion of '" << value.thread_id() << " " << value.elem_id()
                      << "' at tick " << tick << " was found\n";
            return 1;
        }
        /* std::cout << "Delete key " << insertions[thread_id][id].key << std::endl; */
        for (size_t i = 0; i < insertions.size(); ++i) {
            while (insert_index[i] < insertions[i].size() && insertions[i][insert_index[i]].tick < tick) {
                replay_heap.insert({insertions[i][insert_index[i]].key, 0});
                /* std::cout << "Insert " << insertions[i][insert_index[i]].key << " at tick " */
                /*           << insertions[i][insert_index[i]].tick << " (" << i << " " << insert_index[i] << ")" */
                /*           << std::endl; */
                ++insert_index[i];
            }
        }
        /* std::cout << std::endl; */
        /* if (auto it = replay_heap.lower_bound(insertions[value.thread_id()][value.elem_id()].key); */
        /*     it != replay_heap.end() && it->first == insertions[value.thread_id()][value.elem_id()].key) { */
        /*     size_t rank_error = static_cast<size_t>(std::distance(replay_heap.begin(), it)); */
        /*     if (rank_error >= rank_histogram.size()) { */
        /*         rank_histogram.resize(rank_error + 1, 0); */
        /*     } */
        /*     ++rank_histogram[rank_error]; */
        /*     if (it->second >= delay_histogram.size()) { */
        /*         delay_histogram.resize(it->second + 1, 0); */
        /*     } */
        /*     ++delay_histogram[it->second]; */
        /*     for (auto smaller = replay_heap.begin(); smaller != it; ++smaller) { */
        /*         ++smaller->second; */
        /*     } */
        /*     replay_heap.erase(it); */
        /* } else { */
        /*     /1* if (it == replay_heap.end()) { *1/ */
        /*     /1*     std::cout << "No element was found" << std::endl; *1/ */
        /*     /1* } else { *1/ */
        /*     /1*     std::cout << "Next greater element in heap is " << *it << std::endl; *1/ */
        /*     /1* } *1/ */
        /*     std::cerr << "Element with key " << insertions[value.thread_id()][value.elem_id()].key << " and value '" */
        /*               << value.thread_id() << " " << value.elem_id() << "' was deleted before being inserted\n"; */
        /*     return 1; */
        /* } */
    }
    std::clog << "Processed 100%" << std::endl;
    {
        auto out_f = std::ofstream{out_rank};
        for (size_t i = 0; i < rank_histogram.size(); ++i) {
            if (rank_histogram[i] > 0) {
                out_f << i << " " << rank_histogram[i] << '\n';
            }
        }
        out_f.close();
    }
    {
        auto out_f = std::ofstream{out_delay};
        for (size_t i = 0; i < delay_histogram.size(); ++i) {
            if (delay_histogram[i] > 0) {
                out_f << i << " " << delay_histogram[i] << '\n';
            }
        }
        out_f.close();
    }
    std::clog << "Failed deletions: " << failed_deletions << std::endl;
}
