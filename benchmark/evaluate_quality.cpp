#include <algorithm>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <numeric>
#include <set>
#include <unordered_map>
#include <vector>

#include "cxxopts.hpp"

struct deletion_log {
    uint64_t tick;
    std::optional<std::pair<unsigned int, uint32_t>> value;
};

std::istream& operator>>(std::istream& in, deletion_log& line) {
    std::pair<unsigned int, uint32_t> value;
    in >> line.tick >> value.first >> value.second;
    line.value = value;
    return in;
}

std::ostream& operator<<(std::ostream& out, deletion_log const& line) {
    if (line.value) {
        out << "Tick: " << line.tick << " Other thread id: " << line.value->first << " Value: " << line.value->second;
    } else {
        out << "Tick: " << line.tick << " Failed";
    }
    return out;
}

struct insertion_log {
    uint64_t tick;
    uint32_t key;
};

std::istream& operator>>(std::istream& in, insertion_log& line) {
    in >> line.tick >> line.key;
    return in;
}

std::ostream& operator<<(std::ostream& out, insertion_log const& line) {
    out << "Tick: " << line.tick << " Key: " << line.key;
    return out;
}

bool operator<(insertion_log const& lhs, insertion_log const& rhs) {
    return lhs.tick < rhs.tick;
}

bool operator==(insertion_log const& lhs, insertion_log const& rhs) {
    return lhs.key == rhs.key && lhs.tick == rhs.tick;
}
bool operator!=(insertion_log const& lhs, insertion_log const& rhs) {
    return !(lhs == rhs);
}

int main(int argc, char* argv[]) {
    std::filesystem::path out_rank;
    std::filesystem::path out_delay;

    cxxopts::Options options(argv[0], "Parses the logs generated by the quality benchmarks");
    options.positional_help("INSERT DELETION");
    // clang-format off
    options.add_options()
      ("r,out-rank", "The output of the rank histogram", cxxopts::value<std::filesystem::path>(out_rank)->default_value("rank_histgram.txt"), "PATH")
      ("d,out-delay", "The output of the delay histogram", cxxopts::value<std::filesystem::path>(out_delay)->default_value("delay_histogram.txt"), "PATH")
      ("h,help", "Print this help");
    // clang-format on

    try {
        auto result = options.parse(argc, argv);
        if (result.count("help")) {
            std::cerr << options.help() << std::endl;
            std::exit(0);
        }
    } catch (cxxopts::OptionParseException const& e) {
        std::cerr << e.what() << '\n';
        return 1;
    }

    std::vector<std::vector<insertion_log>> insertions;
    std::vector<deletion_log> deletions;
    std::clog << "Reading quality log file from stdin..." << std::endl;
    unsigned int num_threads;
    std::cin >> num_threads;
    if (!std::cin || num_threads == 0) {
        std::cerr << "Invalid number of threads" << std::endl;
        return 1;
    }
    insertions.resize(num_threads);
    char op;
    unsigned int thread_id;
    bool deleting = false;
    while (std::cin >> op >> thread_id) {
        if (thread_id >= num_threads) {
            std::cerr << "Thread id " << thread_id << " too high (Max: " << num_threads - 1 << ')' << std::endl;
            return 1;
        }
        if (op == 'i') {
            if (deleting) {
                std::cerr << "Insertion following a deletion" << std::endl;
                return 1;
            }
            insertion_log ins;
            std::cin >> ins;
            if (!insertions[thread_id].empty() && ins.tick < insertions[thread_id].back().tick) {
                std::cerr << "Insertion\n\t" << ins << "\nhappens before previous insertion" << std::endl;
                return 1;
            }
            insertions[thread_id].push_back(ins);
        } else if (op == 'd') {
            deleting = true;
            deletion_log del;
            std::cin >> del;
            if (del.value->first >= num_threads) {
                std::cerr << "Thread id " << del.value->first << " too high (Max: " << num_threads - 1 << ')'
                          << std::endl;
                return 1;
            }
            if (del.value->second >= insertions[del.value->first].size()) {
                std::cerr << "No insertion corresponding to deletion\n\t" << del << std::endl;
                return 1;
            }
            if (del.tick < insertions[del.value->first][del.value->second].tick) {
                std::cerr << "Deletion of \n\t" << del << "\nhappens before its insertion" << std::endl;
                return 1;
            }
            deletions.push_back(del);
        } else if (op == 'f') {
            deleting = true;
            uint64_t tick;
            std::cin >> tick;
            deletions.push_back(deletion_log{tick, std::nullopt});
        } else {
            std::cerr << "Invalid operation: " << op << std::endl;
            return 1;
        }
    }

    std::clog << "Sorting deletions...\n";
    std::sort(deletions.begin(), deletions.end(), [](auto const& lhs, auto const& rhs) { return lhs.tick < rhs.tick; });
    std::vector<size_t> rank_histogram;
    std::vector<size_t> delay_histogram;
    rank_histogram.reserve(10'000);
    delay_histogram.reserve(10'000);
    std::clog << "Replaying operations...\n";
    std::multimap<uint64_t, size_t> replay_heap{};
    std::vector<size_t> insert_index(insertions.size());
    uint64_t failed_deletions = 0;
    for (size_t i = 0; i < deletions.size(); ++i) {
        if (!deletions[i].value) {
            if (replay_heap.empty()) {
                continue;
            }
            for (auto& [num, delay] : replay_heap) {
                ++delay;
            }
            ++failed_deletions;
            ++rank_histogram[static_cast<size_t>(replay_heap.size())];
        }

        // Inserting everything before next deletion
        for (size_t t = 0; t < insertions.size(); ++t) {
            while (insert_index[t] < insertions[t].size() && insertions[t][insert_index[t]].tick < deletions[i].tick) {
                replay_heap.insert({insertions[t][insert_index[t]].key, 0});
                ++insert_index[t];
            }
        }

        if (auto it = replay_heap.lower_bound(insertions[deletions[i].value->first][deletions[i].value->second].key);
            it != replay_heap.end() &&
            it->first == insertions[deletions[i].value->first][deletions[i].value->second].key) {
            size_t rank_error = static_cast<size_t>(std::distance(replay_heap.begin(), it));
            if (rank_error >= rank_histogram.size()) {
                rank_histogram.resize(rank_error + 1, 0);
            }
            ++rank_histogram[rank_error];
            if (it->second >= delay_histogram.size()) {
                delay_histogram.resize(it->second + 1, 0);
            }
            ++delay_histogram[it->second];
            for (auto smaller = replay_heap.begin(); smaller != it; ++smaller) {
                ++smaller->second;
            }
            replay_heap.erase(it);
        } else {
            std::cerr << "Element\n\t" << insertions[deletions[i].value->first][deletions[i].value->second] << " "
                      << deletions[i].value->second << "\nis not in the heap at deletion time" << std::endl;
            return 1;
        }
        if (i % 10'000 == 0) {
            std::clog << "\rProcessed " << std::setprecision(4)
                      << 100. * static_cast<double>(i) / static_cast<double>(deletions.size()) << "%";
        }
    }
    std::clog << "\rProcessed 100.0%" << std::endl;
    {
        auto out_f = std::ofstream{out_rank};
        for (size_t i = 0; i < rank_histogram.size(); ++i) {
            if (rank_histogram[i] > 0) {
                out_f << i << " " << rank_histogram[i] << '\n';
            }
        }
        out_f.close();
    }
    {
        auto out_f = std::ofstream{out_delay};
        for (size_t i = 0; i < delay_histogram.size(); ++i) {
            if (delay_histogram[i] > 0) {
                out_f << i << " " << delay_histogram[i] << '\n';
            }
        }
        out_f.close();
    }
    std::clog << "Histograms have been written" << std::endl;
    std::clog << "Failed deletions: " << failed_deletions << std::endl;
    return 0;
}
