#include <algorithm>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <numeric>
#include <set>
#include <unordered_map>
#include <vector>

#include "cxxopts.hpp"

struct insertion_log {
    uint64_t tick;
    uint64_t key;
};

bool operator<(insertion_log const& lhs, insertion_log const& rhs) {
    return lhs.tick < rhs.tick;
}

bool operator==(insertion_log const& lhs, insertion_log const& rhs) {
    return lhs.key == rhs.key && lhs.tick == rhs.tick;
}
bool operator!=(insertion_log const& lhs, insertion_log const& rhs) {
    return !(lhs == rhs);
}

struct deletion_log {
    uint64_t tick;
    uint64_t thread_id : 8;
    uint64_t id : 56;
};

int main(int argc, char* argv[]) {
    std::filesystem::path in;
    std::filesystem::path del;

    cxxopts::Options options(argv[0], "Parses the logs generated by the quality benchmarks");
    options.positional_help("INSERT DELETION");
    // clang-format off
    options.add_options()
      ("insert_file", "The log of the insertions", cxxopts::value<std::filesystem::path>(in), "PATH")
      ("delete_file", "The log of the deletions", cxxopts::value<std::filesystem::path>(del), "PATH")
      ("positional", "", cxxopts::value<std::vector<std::filesystem::path>>())
      ("h,help", "Print this help");
    // clang-format on

    options.parse_positional({"insert_file", "delete_file", "positional"});

    try {
        auto result = options.parse(argc, argv);
        if (result.count("help")) {
            std::cerr << options.help() << std::endl;
            std::exit(0);
        }
        if (result.count("insert_file") == 0 || result.count("delete_file") == 0) {
            std::cerr << "Provide insertion file and deletion file!\n\n";
            std::cerr << options.help() << std::endl;
            std::exit(1);
        }
    } catch (cxxopts::OptionParseException const& e) {
        std::cerr << e.what() << '\n';
        return 1;
    }
    std::vector<std::vector<insertion_log>> insertions;
    std::vector<deletion_log> deletions;
    auto in_f = std::ifstream{in};
    auto del_f = std::ifstream{del};
    if (!in_f.is_open()) {
        std::cerr << "failed to open " << in << '\n';
        return 1;
    }
    if (!del_f.is_open()) {
        std::cerr << "failed to open " << del << '\n';
        return 1;
    }
    {
        std::cout << "Reading insertion file...\n";
        uint64_t thread_id;
        uint64_t tick;
        uint64_t key;
        while (in_f >> thread_id >> tick >> key) {
            if (thread_id >= insertions.size()) {
                insertions.resize(thread_id + 1);
                insertions[thread_id].reserve(10000);
            }
            insertions[thread_id].push_back(insertion_log{tick, key});
        }
        in_f.close();
    }
    {
        std::cout << "Reading deletion file...\n";
        uint64_t thread_id;
        uint64_t tick;
        uint64_t other_thread_id;
        uint64_t id;
        deletions.reserve(1'000'000);
        while (del_f >> thread_id >> tick >> other_thread_id >> id) {
            deletions.push_back(deletion_log{tick, other_thread_id, id});
        }
        del_f.close();
    }
    /* std::cout << "Num deletions: " << deletions.size() << std::endl; */
    std::cout << "Sorting deletions...\n";
    std::sort(deletions.begin(), deletions.end(), [](auto const& lhs, auto const& rhs) { return lhs.tick < rhs.tick; });
    std::vector<size_t> rank_histogram;
    rank_histogram.reserve(10'000);
    std::cout << "Evaluating deletions...\n";
    std::multiset<uint64_t> replay_heap{};
    std::vector<size_t> insert_index(insertions.size());
    uint64_t failed_deletions = 0;
    size_t counter = 0;
    size_t progress = 0;
    for (auto const& [tick, thread_id, id] : deletions) {
        if ((10 * counter) / deletions.size() >= progress) {
            std::cout << "Processed " << std::setprecision(3)
                      << 100. * static_cast<double>(counter) / static_cast<double>(deletions.size()) << "%\n";
            ++progress;
        }
        ++counter;
        /* std::cout << "Deletion tick is at " << tick << std::endl; */
        if (thread_id == (1u << 8) - 1) {
            if (!replay_heap.empty()) {
                ++failed_deletions;
                ++rank_histogram[static_cast<size_t>(replay_heap.size())];
            }
            continue;
        }
        if (thread_id >= insertions.size() || id >= insertions[thread_id].size()) {
            std::cerr << "No insertion corresponding to deletion of '" << thread_id << " " << id << "' at tick " << tick
                      << " was found\n";
            return 1;
        }
        /* std::cout << "Delete key " << insertions[thread_id][id].key << std::endl; */
        for (size_t i = 0; i < insertions.size(); ++i) {
            while (insert_index[i] < insertions[i].size() && insertions[i][insert_index[i]].tick < tick) {
                replay_heap.insert(insertions[i][insert_index[i]].key);
                /* std::cout << "Insert " << insertions[i][insert_index[i]].key << " at tick " */
                /*           << insertions[i][insert_index[i]].tick << " (" << i << " " << insert_index[i] << ")" */
                /*           << std::endl; */
                ++insert_index[i];
            }
        }
        /* std::cout << std::endl; */
        if (auto it = replay_heap.lower_bound(insertions[thread_id][id].key);
            it != replay_heap.end() && *it == insertions[thread_id][id].key) {
            size_t rank_error = static_cast<size_t>(std::distance(replay_heap.begin(), it));
            if (rank_error >= rank_histogram.size()) {
                rank_histogram.resize(rank_error + 1, 0);
            }
            ++rank_histogram[rank_error];
            replay_heap.erase(it);
        } else {
            /* if (it == replay_heap.end()) { */
            /*     std::cout << "No element was found" << std::endl; */
            /* } else { */
            /*     std::cout << "Next greater element in heap is " << *it << std::endl; */
            /* } */
            std::cerr << "Element with key " << insertions[thread_id][id].key << " and value '" << thread_id << " "
                      << id << "' was deleted before being inserted\n";
            return 1;
        }
    }
    auto out_f = std::ofstream{"histogram.txt"};
    for (size_t i = 0; i < rank_histogram.size(); ++i) {
        if (rank_histogram[i] > 0) {
            out_f << i << " " << rank_histogram[i] << '\n';
        }
    }
    out_f.close();
    std::cout << "Failed deletions: " << failed_deletions << std::endl;
}
